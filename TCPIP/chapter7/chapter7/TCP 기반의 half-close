일방적인 연결종료의 문제점
	리눅스의 close 함수호출과 윈도우의 closesocket 함수호출은 완전종료를 의미한다.
	완전종료라는 것은 데이터를 전송하는 물론이거니와 수신하는 것 조차 더 이상 불가능한 상황을 의미한다.

	close & closesocket 기능
		- 소켓의 완전소멸을 의미한다.
		- 소켓이 소멸되므로 더 이상의 입출력이 불가능
		- 상대방의 상태에 상관없이 일반적인 종료의 형태
		- 상대 호스트의 데이터 송수신이 아직 완료되지 않은 상황이라면, 문제가 발생
		- 대안으로 half-close 기법이 존재한다.

	half-close는 전송은 가능하지만 수신은 불가능한 상황, 혹은 수신은 가능하지만 전송은 불가능한 상황을 뜻한다. 말 그대로 스트림의 반만 닫는다.

소켓과 스트림(stream)
	두 호스트가 연결되면 상호간에 데이터의 송수신이 가능한 상태가 된다. 이러한 상태를 가리켜 '스트림이 형성된 상태'
	즉, 두 소켓이 연결되어서 데이터의 송수신이 가능한 상태를 일정의 스트림으로 보는 것이다.
	두 호스트간에 소켓이 연결되면, 각 호스트 별로 입력 스트림과 출력 스트림이 형성된다.
	물론 한 호스트의 입력 스트림은 다른 호스트의 출력 스트림으로 이어지고, 한 호스트의 출력 스트림은 다른 호스트의 입력 스트림으로 이어진다.
	우아한 종료라는 것은 한번에 이 두 스크림을 모두 끊어버리는 것이 아니라. 이 중 하나의 스트림만 끊는 것이다.

우아한 종료를 위한 shotdown 함수
	
	#include <sys/socket.h>
	
	int shotdown(int sock, int howto)
		-> 성공 시 0, 실패 시 -1 반환
		sock 종료할 소켓의 파일 디스크립터
		howto 종료방법에 대한 정보 전달

	함수호출 시 두 번째 매개변수에 전달되는 인자에 따라서 종료의 방법이 결정된다.
		- SHUT_RD 입력 스트림 종료
		- SHUT-WR 출력 스트림 종료
		- SHUT_RDWR 입출력 스트림 종료

	두 번째 인자로 SHUT_RD가 전달되면 입력 스트림이 종료되어 더 이상 데이터를 수신할 수 없는 상태가 된다.
	SHUT_WR가 두 번째 인자로 전달되면 출력 스트림이 종료되어 더 이상의 데이터 전송이 불가능해진다.
	SHUT_RDWR가 전달되면 입력 스트림과 출력 스트림이 모두 종료되는데, 이는 shutdown 함수를 한번은 shut_rd를 인자로, 또 한번은 shut_wr을 인자로 두 번 호출한 것과 같다.

half-close가 필요한 이유
	
	종료를 원한다는 것은, 더이상 전송할 데이터가 없다는 것이다.
	따라서 입력 스트림은 종료를 시켜도 된다.
	다만 상대방도 종료를 원하는 지 확인되지 않은 상황이므로 출력 스트림은 종료시키지 않을 필요가 있다.
	때문에 일반적으로 half-close라 하면, 입력스트림만 종료하는 것을 의미한다.

