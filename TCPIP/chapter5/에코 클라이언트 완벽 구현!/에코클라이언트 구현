에코서버의 문제
	서버는 데이터의 경계를 구분하지 않고 수신된 데이터를 그대로 전송할 의무만 갖는다.
	tcp가 본디 데이터의 경가가 없는 프로토콜이므로, 두번의 write나 세번의 write함수호출을 통해서 데이터를 전송하건 문제가 되지않는다.
	반면, 클라이언트는 문장단위로 데이터를 송신하기 때문에 데이터의 경계를 구분해야한다.
	때문에 이와 같은 데이터 송수신 방식은 문제가 된다.
	tcp의 read & write(send,recv)함수호출은 데이터의 경계를 구분하지 않기 떄문이다.

에코 클라이언트의 해결책
		str_len=write(sock, message, strlen(message));
		recv_len = 0;
		while(recv_len<str_len)
		{
			recv_cnt=read(sock,&messaga[recv_len], BUF_SIZE-1);
			if(recv_cnt == -1)
				error_handling("read() error");
			recv_len+=recv_cnt;
		}
		message[recv_len] = 0;
		printf("Message from server: %s", message)
	
	write 함수호출을 통해서 전송된 데이터의 길이만큼 일겅들이기 위해서 반복문 삽입이 필요하다.
	이것이 tcp기반으로 데이터를 구분지어 읽어들이는데 부가적으로 필요한 구분이다.

	이전 예제에서는 단순히 read 함수를 한번 호출하고 말았던 것을 이 예제에서는 전송한 데이터의 크기만큼 데이터를 수신하기 위해서 read 함수를 반복호출 하고있다.
	따라서 정확히 전송한 바이트 크기만큼 데이터를 수신할 수 있게 되었다.

	보낸 만큼 받아야 하므로 recv_len에 저장된 값과 str_len에 저장된 값이 일치하는 시점이 while문을 빠져나가는 시점이 되니 반복문이 논리적이다.
	반복문을 구성할 때에는 예측하지 못한 상황에 따른 무한루프의 형성 가능성을 최소화하는 것이 좋다.

어플리케이션 프로토콜의 정의
	수신할 데이터의 크기를 파악하는 것이 불가능한 경우에는 어떻게 데이터를 송수신해야 할까?
		-> 이러한 경우 필요한 것이 어플리케이션 프로토콜의 정의이다.
	
	데이터의 송수신 과정에서도 데이터의 끝을 파악할 수 있는 약속을 별도로 정의해서 데이터의 끝을 표현하거나,
	송수신될 데이터의 크기를 미리 알려줘서 그에 따른 대비가 가능해야 한다.
	서버, 클라이언트의 구현과정에서 이렇게 하나, 둘씩 만들어지는 약속을 모아서 '어플리케이션 프로토콜'이라고 한다.

	AP(어플리케이션 프로토콜)가 정의되면 클라이언트와 서버 간의 데이터 송수신에 사용되는 데이터 포맷이 결정된다.

