TCP 서버에서의 기본적인 함수호출 순서

socket() 소켓생성

bind() 소켓주소 할당

listen() 연결요청 대기상태

accept() 연결 허용

read() / write() 데이터 송수신

close() 연결 종료

제일 먼저 socket 함수의 호출을 통해서 소켓을 생성한다.그리고 주소정보를 담귀 위한 구조체 변수를 선언 및 초기화해서 bind 함수를 호출하여 소켓에 주소를 할당한다.
bind함수까지 호출이 되면 주소가 할당된 소켓을 얻게된다.따라서 listen함수의 호출을 통해서 연결요청이 가능한 상태가 되어야 한다.

연결요청 대기상태로의 진입

bind 함수호출을 통해서 소켓에 주소까지 할당했다면,
이번에는 listen 함수호출을 통해서 '연결요청 대기상태'로 들어갈 차례이다.
listen 함수가 호출되어야 클라이언트가 연결요청을 할 수 있는 상태가 된다.

연결요청도 일종의 데이터 전송이다.따라서 연결요청은 받아들이기 위해서도 하나의 소켓이 필요하다.
그리고 이 소켓을 가리켜 서버소켓 또는 리스닝 소켓이라 한다.listen함수의 호출은 소켓을 리스닝 소켓이 되게한다.

	#incldue <sys / socket.h>

	int listen(int sock, int backlog);
		성공 시 0, 실패 시 -1 반환
		sock - 연결요청 대기상태에 두고자 하는 소켓의 파일 디스크립터 전달, 이 함수의 ㅇ니자로 전달된 디스크립터의 소켓이 서버 소켓이 된다.
		backlog - 연결요청 대기 큐의 크기정보 전달. 5가 전달되면 큐의 크기가 5가 되어 클라이언트의 연결요청을 5개까지 대기시킬 수 있다.

		서버가 '연결요청 대기상태'에 있다는 것은 클라잉너트가 연결요청을 했을 때 연결이 수락될 때까지 연결요청 자체를 대기시킬 수 있는 상태에 있다는 것을 의미한다.
		tcp연결 소켓은 1:1 연결하고 연결된 정보를 보내고 이전 연결을 종료한다.

		listen 함수의 첫 번째 인자로 전달된 파일 디스크립터의 소켓이 어떤 용도로 사용되는지 알 수 있다.
		클라이언트의 연결요청도 인터넷을 통해서 흘러 들어오는 일종의 데이터 전송이기 때문에, 이것을 받아들이려면 당연히 소켓이 하나 있어야한다.
		서버 소켓의 역활이 바로 이것이다. 즉, 연결요청을 맞이하는, 일종의 문지기 또는 문의 역활이라 볼 수 있다.

		listen함수가 호출되면, 이렇듯 문지기의 역활을 하는 서버 소켓이 만들어지고, listen함수의 두 번째 인자로 전달되는 정수의 크기에 해당하는 대기실이 만들어진다.
		이 대기실을 가리켜 '연결요청 대기 큐'라 하며, 서버 소켓과 연결요청 대기 큐가 완전히 준비되어서 클라이언트의 연결요청을 받아들일 수 있는 상태를 가리켜 '연결요청 대기상태'라 한다.

클라이언트의 연결요청 수락
	listen 함수호출 이후에 클라리언트의 연결요청이 들어왔다면, 들어온 순서대로 연결요청을 수락해야 한다.
	연결요청을 수락한다는 것은 클라이언트와 데이터를 주고받을 수 있는 상태가 됨을 의미한다.
	따라서 이러한 상태가 되기 위해 무엇이 필요한지 짐작해야한다. 당연히 소켓이 필요하다.

	'서버 소켓을 사용하면 되지않을까'라는 생각은 틀리다. 서버 소켓은 문지기이기 때문이다.
	하지만 우리가 직접 만들 필요는 없으며 accept함수를 통해 자동으로 만들어지고 연결된다.

	#include <sys/socket.h>

	int accepct(int sock, struct sockaddr* addr, socklent_t * addrlen);
		sock - 서버 소켓의 파일 디스크립터 전달.
		addr - 연결요청 한 클라이언트의 주소정보를 담을 변수의 주소 값 전달, 함수호출이 완료되면 인자로 전달된 주소의 변수에는 클라이언트의 주소정보가 채워진다.
		addrlen - 두 번째 매개변수 addr에 전달된 주소의 변수 크기를 바이트 단위로 전달, 단 크기정보를 변수에 저장한 다음에 변수의 주소 값을 전달한다.
				  그리고 함수호출이 완료되면 크기정보로 채워저 있던 변수에는 클라이언트의 주소정보 길이가 바이트 단위로 계산되어 채워진다.

	'연결요청 대기 큐'에서 대기중인 클라이언트의 연결요청을 수락하는 기능의 함수이다.
	따라서 accept 함수는 호출성공 시 내부적으로 데이터 입출력에 사용할 소켓을 생성하고, 그 소켓의 파일 디스크립터를 반환한다.
	중요한 점은 소켓이 자동으로 생성되어, 연결요청을 한 클라이언트 소켓에 연결까지 이뤄진다는 점이다.

	연결요청 정보를 참조하여 클라이언트 소켓과의 통신을 위한 별도의 소켓을 추가로 하나 더 생성한다.
		그리고 이렇게 생성된 소켓을 대상으로 데이터의 송수신이 진행된다.

	중요한 내용!
		if 서버소켓의 port번호가 8080일때,
			연결요청하면 운영체제는 소켓을 하나 더 만드는데 이 소켓은 과연 port번호가 몇번이 될까?
			port는 중복이 되지 않지만 운영체제가 맵핑을 하여 8080으로 연결한다. 그리고 os가 매핑주소를 가지고 있다.
			즉, 서버 소켓으로 생성된(연결요청으로 생성된) 소켓은 동일한 port번호로 연결되고, 데이터 전송지(클라이언트의 IP)를 참조하여 실질적으로 연결되어 있는 소켓에 전달해 준다.


TCP 클라이언트의 기본적인 함수호출 순서
	클라이언트의 구현과정은 서버에 비해 매우 간단하다. '소켓의 생성', 그리고 '연결의 요청'이 전부이다.

			socket() 소켓생성

			connect() 연결요청

			read()/write() 데이터 송수신

			close() 연결종료

	클라이언트의 경우 소켓을 생성하고, 이 소켓을 대상으로 연결의 요청을 위해서 connect함수를 호출하는 것이 전부이다.
	그리고 connect 함수를 호출할 때 연결할 서버의 주소도 함께 전달한다.

	서버의 구현과정과 비교해서 차이가 있는 부분은 '연결요청'이라는 과정이다.
	클라이언트 소켓을 생성한 후에 서버로 연결을 요청하는 과정이다.
	서버는 listen함수를 호출한 이후부터 연결요청 대기 큐를 만들어 놓는다.
	그 이후부터 클라이언트는 연결요청을 할 수 있다.

	#include <sys/socket.h>

	int connect(int sock, struct sockaddr * servaddr, socklen_t addrlen);
		성공 시 0, 실패 시 -1 반환
		sock - 클라이언트 소켓의 파일 디스크립터 전달.
		servaddr - 연결요청 할 서버의 주소정보를 담은 변수의 주소 값 전달
		addrlen - 두 번째 매개변수 servaddr에 전달된 주소의 변수 크기를 바이트 단위로 전달

		클라이언트에 의해서 connect 함수가 호출되면 다음 둘 중 한가지 상황이 되어야 함수가 반환된다.
			- 서버에 의해 연결요청이 접수되었다.
			- 네트워크 단절 등 오류상황이 발생해서 연결요청이 중단되었다.

		'연결요청의 접수'는 서버의 accept 함수호출을 의미하는 것이 아니라는 점이다.
		클라이언트의 연결요청 정보가 서버의 연결요청 대기 큐에 등록된 상황을 의미한다.
		connect 함수가 반환했더라도 당장에 서비스가 이뤄지지 않을 수도 있음을 기억하자.

TCP기반 서버, 클라이언트의 함수호출 관계

	서버의 listen함수호출이후에야 클라리언트의 connect 함수호출이 유효하다.
	서버는 소켓 생성 이후에 bind, listen 함수의 연이은 호출을 통해 대기상태에 들어가고,
	클라이언트는 connect 함수호출을 통해서 연결요청을 하게된다.
	특히, 클라이언트는 서버소켓의 listen 함수호출 이후에 connect함수호출이 가능하다는 사실을 기억할 필요가 있다.
	클라이언트가 connect 함수를 호출하기에 앞서 서버가 accept 함ㅅ를 먼저 호출할 수 있다는 사실도 기억하자.
	물론 이때는 클라이언트가 connect 함수를 호출할 때까지 서버는 accept함수가 호출된 위치에서 블로킹 상태에 놓이게 된다.