#pragma once
#include <iostream>
using namespace std;

#pragma region 생성자/소멸자
// 생성자 / 소멸자 정의
// <문법>
// - 생성자
// [클래스 이름]([매개 변수 목록])
//{
//		[실행문]들
//}
// 생성자는 매개 변수를 사용할 수 있다.
// = 생성자 오버로딩 가능.

// - 소멸자
// ~[클래스 이름]()
// {
//		[실행문]들
// }
// 소멸자는 매개 변수를 사용할 수 없다.
// = 소멸자 오버로딩 불가능.]

// 일반적으로
// 생성자 : 클래스의 초기화.
// 소멸자 : 클래스의 데이터 해제.
// 할 때 사용.
#pragma endregion 

// 얕은 복사와 깊은 복사
// 
// 얕은 복사 : 데이터를 있는 그대로 복사.
// ★★★★★★★★
// 얕은 복사의 문제점
// : 클래스의 멤버 중, 동적 할당한 메모리의 주소를 가진 포인터의 경우,
// 해당 포인터가 가리키는 실제 메모리가 복사가 되지 않고
// 대신 포인터 안에 있는 주소'만' 복사가 된다.

// ★★★★★★★★
// 깊은 복사 : 
// : 클래스의 멤버 중, 동적 할당한 메모리의 주소를 가진 포인터의 경우,
// 해당 포인터의 주소를 복사하지 않음.
// 대신 
// 1. 새로운 메모리를 동적 할당.
// 2. 할당한 메모리에 실제 데이터 복사.
// 
// 깊은 복사 구현!
// - 복사 생성자
// 클래스의 객체를 복사할 떄 사용하는 생성자.
// <복사 생성자의 형식>
// [클래스 이름](const [클래스 이름]& [매개 변수 이름]
// {
//		[실행문]들.
// }
// 
// - 대입 연산자 오버로딩.
// C++의 연산자는 함수와 동일하다.
// 연산자 오버로딩 : 기존의 연산자에서 실행하는 내용을 다른 내용으로 작성!

class Human
{
private:
	char* name;
	int age;

public:
	void Setdata(const char* name, int age);
	void DeleteData();
	void Show();

public:
	Human& operator=(const Human& copyHuman); // 대입 연산자 오버로딩

public:
	Human(); // 생성자
	Human(const char* name, int age);
	Human(const Human& copyHuman); // 복사 생성자.
	~Human(); // 소멸자
};

